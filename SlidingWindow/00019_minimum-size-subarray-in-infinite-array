https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/description/


2875. Minimum Size Subarray in Infinite Array
Medium
Topics
Companies
Hint
You are given a 0-indexed array nums and an integer target.

A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.

Return the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no such subarray return -1.

 

Example 1:

Input: nums = [1,2,3], target = 5
Output: 2
Explanation: In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.
Example 2:

Input: nums = [1,1,1,2,3], target = 4
Output: 2
Explanation: In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.
Example 3:

Input: nums = [2,4,6,8], target = 3
Output: -1
Explanation: In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
It can be proven that there is no subarray with sum equal to target = 3.
 

Constraints:

1 <= nums.length <= 105
1 <= nums[i] <= 105
1 <= target <= 109



# java


class Solution {
  public int minSizeSubarray(int[] nums, int target) {
    final long sum = Arrays.stream(nums).asLongStream().sum();
    final int n = nums.length;
    final int remainingTarget = (int) (target % sum);
    final int repeatLength = (int) (target / sum) * n;
    if (remainingTarget == 0)
      return repeatLength;

    int suffixPlusPrefixLength = n;
    long prefix = 0;
    HashMap<Long, Integer> prefixToIndex = new HashMap<>();
    prefixToIndex.put(0L, -1);

    for (int i = 0; i < 2 * n; ++i) {
      prefix += nums[i % n];
      if (prefixToIndex.containsKey(prefix - remainingTarget))
        suffixPlusPrefixLength =
            Math.min(suffixPlusPrefixLength, i - prefixToIndex.get(prefix - remainingTarget));
      prefixToIndex.put(prefix, i);
    }

    return suffixPlusPrefixLength == n ? -1 : repeatLength + suffixPlusPrefixLength;
  }
}



or



class Solution {
    public int minSizeSubarray(int[] nums, int target) {
        long s = Arrays.stream(nums).sum();
        int n = nums.length;
        int a = 0;
        if (target > s) {
            a = n * (target / (int) s);
            target -= target / s * s;
        }
        if (target == s) {
            return n;
        }
        Map<Long, Integer> pos = new HashMap<>();
        pos.put(0L, -1);
        long pre = 0;
        int b = 1 << 30;
        for (int i = 0; i < n; ++i) {
            pre += nums[i];
            if (pos.containsKey(pre - target)) {
                b = Math.min(b, i - pos.get(pre - target));
            }
            if (pos.containsKey(pre - (s - target))) {
                b = Math.min(b, n - (i - pos.get(pre - (s - target))));
            }
            pos.put(pre, i);
        }
        return b == 1 << 30 ? -1 : a + b;
    }
}


or


class Solution {
    public int minSizeSubarray(int[] A, int target) {
        long sumA = 0L, su = 0L;
        for (int a : A)
            sumA += a;
        int n = A.length, k = (int) (target / sumA), res = n;
        target %= sumA;
        if (target == 0) {
            return k * n;
        }

        HashMap<Long, Integer> dp = new HashMap<>();
        dp.put(0L, -1);

        for (int i = 0; i < 2 * n; ++i) {
            su += A[i % n];
            if (dp.containsKey(su - target)) {
                res = Math.min(res, i - dp.get(su - target));
            }
            dp.put(su, i);
        }

        return res < n ? res + k * n : -1;
    }
}


or



class Solution {
    public int minSizeSubarray(int[] nums, int target) {
        long total = Arrays.stream(nums).sum(), sum = 0;
        int n = nums.length, partial = n, complete = n * (int)(target / total), start = 0;
        target %= total;
        for (int end = 0; end < 2 * n; end++) {
            sum += nums[end % n];
            while (sum > target) {
                sum -= nums[start++ % n];
            }
            if (sum == target) {
                partial = Math.min(partial, end - start + 1);
            }
        }
        return partial != n ? partial + complete : -1;
    }
}


or


class Solution {
    public int minSizeSubarray(int[] nums, int target) {
        int end = 0;
        int start = 0;
        
        int n = nums.length;
        int minLength = Integer.MAX_VALUE;
        int sum = 0;
        
        boolean arrayCrossed = false;
        boolean startCrossed = false;
        int endCrossedCount = 0;
        int startCrossedCount = 0;
        
        while(true) {
            if(startCrossed && start <= end)
                break;
            sum += nums[end];
            if(sum == target) {
                int length = (endCrossedCount * n + end + 1) - (startCrossedCount * n + start);
                minLength = Math.min(length, minLength);
            } else if(sum > target) {
                while(sum > target) {
                    sum -= nums[start];
                    start = (start + 1) % n;

                    if(start == 0 && arrayCrossed) {
                        startCrossed = true;
                        startCrossedCount++;
                    }
                }

                if(sum == target) {
                    int length = (endCrossedCount * n + end + 1) - (startCrossedCount * n + start);
                    minLength = Math.min(length, minLength);
                    if(startCrossedCount > 0)
                        break;
                }
            }
            end = (end + 1) % n;
            
            // This means array appended to end of prev array
            if(end == 0 && !arrayCrossed) {
                arrayCrossed = true;
                endCrossedCount++;
            } else if(end == 0)
                endCrossedCount++;
        }
        
        return minLength == Integer.MAX_VALUE ? -1 : minLength;
    }
}


or


